// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DCTL_DCTL_H_
#define FLATBUFFERS_GENERATED_DCTL_DCTL_H_

#include "flatbuffers/flatbuffers.h"

namespace DCTL {

struct Vec2;

struct Color;

struct Snake;
struct SnakeBuilder;
struct SnakeT;

struct GameState;
struct GameStateBuilder;
struct GameStateT;

enum Dir : int8_t {
  Dir_None = 0,
  Dir_Up = 1,
  Dir_Down = 2,
  Dir_Left = 3,
  Dir_Right = 4,
  Dir_MIN = Dir_None,
  Dir_MAX = Dir_Right
};

inline const Dir (&EnumValuesDir())[5] {
  static const Dir values[] = {
    Dir_None,
    Dir_Up,
    Dir_Down,
    Dir_Left,
    Dir_Right
  };
  return values;
}

inline const char * const *EnumNamesDir() {
  static const char * const names[6] = {
    "None",
    "Up",
    "Down",
    "Left",
    "Right",
    nullptr
  };
  return names;
}

inline const char *EnumNameDir(Dir e) {
  if (flatbuffers::IsOutRange(e, Dir_None, Dir_Right)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDir()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2()
      : x_(0),
        y_(0) {
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Color FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;

 public:
  Color()
      : r_(0),
        g_(0),
        b_(0) {
  }
  Color(uint8_t _r, uint8_t _g, uint8_t _b)
      : r_(flatbuffers::EndianScalar(_r)),
        g_(flatbuffers::EndianScalar(_g)),
        b_(flatbuffers::EndianScalar(_b)) {
  }
  uint8_t r() const {
    return flatbuffers::EndianScalar(r_);
  }
  uint8_t g() const {
    return flatbuffers::EndianScalar(g_);
  }
  uint8_t b() const {
    return flatbuffers::EndianScalar(b_);
  }
};
FLATBUFFERS_STRUCT_END(Color, 3);

struct SnakeT : public flatbuffers::NativeTable {
  typedef Snake TableType;
  int32_t player_id = 0;
  int64_t time_stamp = 0;
  std::vector<DCTL::Vec2> tail{};
  DCTL::Dir dir = DCTL::Dir_None;
  std::unique_ptr<DCTL::Color> color{};
};

struct Snake FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SnakeT NativeTableType;
  typedef SnakeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER_ID = 4,
    VT_TIME_STAMP = 6,
    VT_TAIL = 8,
    VT_DIR = 10,
    VT_COLOR = 12
  };
  int32_t player_id() const {
    return GetField<int32_t>(VT_PLAYER_ID, 0);
  }
  int64_t time_stamp() const {
    return GetField<int64_t>(VT_TIME_STAMP, 0);
  }
  const flatbuffers::Vector<const DCTL::Vec2 *> *tail() const {
    return GetPointer<const flatbuffers::Vector<const DCTL::Vec2 *> *>(VT_TAIL);
  }
  DCTL::Dir dir() const {
    return static_cast<DCTL::Dir>(GetField<int8_t>(VT_DIR, 0));
  }
  const DCTL::Color *color() const {
    return GetStruct<const DCTL::Color *>(VT_COLOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PLAYER_ID) &&
           VerifyField<int64_t>(verifier, VT_TIME_STAMP) &&
           VerifyOffset(verifier, VT_TAIL) &&
           verifier.VerifyVector(tail()) &&
           VerifyField<int8_t>(verifier, VT_DIR) &&
           VerifyField<DCTL::Color>(verifier, VT_COLOR) &&
           verifier.EndTable();
  }
  SnakeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SnakeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Snake> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SnakeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SnakeBuilder {
  typedef Snake Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_id(int32_t player_id) {
    fbb_.AddElement<int32_t>(Snake::VT_PLAYER_ID, player_id, 0);
  }
  void add_time_stamp(int64_t time_stamp) {
    fbb_.AddElement<int64_t>(Snake::VT_TIME_STAMP, time_stamp, 0);
  }
  void add_tail(flatbuffers::Offset<flatbuffers::Vector<const DCTL::Vec2 *>> tail) {
    fbb_.AddOffset(Snake::VT_TAIL, tail);
  }
  void add_dir(DCTL::Dir dir) {
    fbb_.AddElement<int8_t>(Snake::VT_DIR, static_cast<int8_t>(dir), 0);
  }
  void add_color(const DCTL::Color *color) {
    fbb_.AddStruct(Snake::VT_COLOR, color);
  }
  explicit SnakeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Snake> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Snake>(end);
    return o;
  }
};

inline flatbuffers::Offset<Snake> CreateSnake(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t player_id = 0,
    int64_t time_stamp = 0,
    flatbuffers::Offset<flatbuffers::Vector<const DCTL::Vec2 *>> tail = 0,
    DCTL::Dir dir = DCTL::Dir_None,
    const DCTL::Color *color = 0) {
  SnakeBuilder builder_(_fbb);
  builder_.add_time_stamp(time_stamp);
  builder_.add_color(color);
  builder_.add_tail(tail);
  builder_.add_player_id(player_id);
  builder_.add_dir(dir);
  return builder_.Finish();
}

inline flatbuffers::Offset<Snake> CreateSnakeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t player_id = 0,
    int64_t time_stamp = 0,
    const std::vector<DCTL::Vec2> *tail = nullptr,
    DCTL::Dir dir = DCTL::Dir_None,
    const DCTL::Color *color = 0) {
  auto tail__ = tail ? _fbb.CreateVectorOfStructs<DCTL::Vec2>(*tail) : 0;
  return DCTL::CreateSnake(
      _fbb,
      player_id,
      time_stamp,
      tail__,
      dir,
      color);
}

flatbuffers::Offset<Snake> CreateSnake(flatbuffers::FlatBufferBuilder &_fbb, const SnakeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GameStateT : public flatbuffers::NativeTable {
  typedef GameState TableType;
  std::vector<std::unique_ptr<DCTL::SnakeT>> snakes{};
};

struct GameState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GameStateT NativeTableType;
  typedef GameStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SNAKES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<DCTL::Snake>> *snakes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DCTL::Snake>> *>(VT_SNAKES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SNAKES) &&
           verifier.VerifyVector(snakes()) &&
           verifier.VerifyVectorOfTables(snakes()) &&
           verifier.EndTable();
  }
  GameStateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GameStateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GameState> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GameStateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GameStateBuilder {
  typedef GameState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_snakes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DCTL::Snake>>> snakes) {
    fbb_.AddOffset(GameState::VT_SNAKES, snakes);
  }
  explicit GameStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GameState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GameState>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameState> CreateGameState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DCTL::Snake>>> snakes = 0) {
  GameStateBuilder builder_(_fbb);
  builder_.add_snakes(snakes);
  return builder_.Finish();
}

inline flatbuffers::Offset<GameState> CreateGameStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<DCTL::Snake>> *snakes = nullptr) {
  auto snakes__ = snakes ? _fbb.CreateVector<flatbuffers::Offset<DCTL::Snake>>(*snakes) : 0;
  return DCTL::CreateGameState(
      _fbb,
      snakes__);
}

flatbuffers::Offset<GameState> CreateGameState(flatbuffers::FlatBufferBuilder &_fbb, const GameStateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline SnakeT *Snake::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SnakeT>(new SnakeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Snake::UnPackTo(SnakeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = player_id(); _o->player_id = _e; }
  { auto _e = time_stamp(); _o->time_stamp = _e; }
  { auto _e = tail(); if (_e) { _o->tail.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tail[_i] = *_e->Get(_i); } } }
  { auto _e = dir(); _o->dir = _e; }
  { auto _e = color(); if (_e) _o->color = std::unique_ptr<DCTL::Color>(new DCTL::Color(*_e)); }
}

inline flatbuffers::Offset<Snake> Snake::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SnakeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSnake(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Snake> CreateSnake(flatbuffers::FlatBufferBuilder &_fbb, const SnakeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SnakeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _player_id = _o->player_id;
  auto _time_stamp = _o->time_stamp;
  auto _tail = _o->tail.size() ? _fbb.CreateVectorOfStructs(_o->tail) : 0;
  auto _dir = _o->dir;
  auto _color = _o->color ? _o->color.get() : 0;
  return DCTL::CreateSnake(
      _fbb,
      _player_id,
      _time_stamp,
      _tail,
      _dir,
      _color);
}

inline GameStateT *GameState::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GameStateT>(new GameStateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GameState::UnPackTo(GameStateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = snakes(); if (_e) { _o->snakes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->snakes[_i] = std::unique_ptr<DCTL::SnakeT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<GameState> GameState::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GameStateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGameState(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GameState> CreateGameState(flatbuffers::FlatBufferBuilder &_fbb, const GameStateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GameStateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _snakes = _o->snakes.size() ? _fbb.CreateVector<flatbuffers::Offset<DCTL::Snake>> (_o->snakes.size(), [](size_t i, _VectorArgs *__va) { return CreateSnake(*__va->__fbb, __va->__o->snakes[i].get(), __va->__rehasher); }, &_va ) : 0;
  return DCTL::CreateGameState(
      _fbb,
      _snakes);
}

inline const DCTL::GameState *GetGameState(const void *buf) {
  return flatbuffers::GetRoot<DCTL::GameState>(buf);
}

inline const DCTL::GameState *GetSizePrefixedGameState(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<DCTL::GameState>(buf);
}

inline bool VerifyGameStateBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<DCTL::GameState>(nullptr);
}

inline bool VerifySizePrefixedGameStateBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<DCTL::GameState>(nullptr);
}

inline void FinishGameStateBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<DCTL::GameState> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedGameStateBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<DCTL::GameState> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<DCTL::GameStateT> UnPackGameState(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<DCTL::GameStateT>(GetGameState(buf)->UnPack(res));
}

inline std::unique_ptr<DCTL::GameStateT> UnPackSizePrefixedGameState(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<DCTL::GameStateT>(GetSizePrefixedGameState(buf)->UnPack(res));
}

}  // namespace DCTL

#endif  // FLATBUFFERS_GENERATED_DCTL_DCTL_H_
